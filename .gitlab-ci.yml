# ======================
# CI Stages
# ======================

stages:
  - test
  - build
  - regression
  - push
  - changelog
  - deploy

# ======================
# Global variables
# ======================

variables:
  DOCKER_DRIVER: overlay2
  SERVICE_NAME: componentlibrary-versioned
  FRONTEND_IMAGE: $CI_REGISTRY_IMAGE/frontend
  IMAGE_TAG: $CI_COMMIT_REF_SLUG
  CURRENT_UID: 1000
  CURRENT_GID: 1000

# ======================
# Snippets
# ======================

.prepare-deploy: &prepare-deploy
  stage: deploy
  image: docker:stable
  services:
    - docker:dind
  before_script:
    - export DOCKER_TAG="$CI_COMMIT_REF_SLUG.$CI_PIPELINE_ID";
    - apk --no-cache add openssh
    # Run ssh-agent (inside the build environment)
    - eval $(ssh-agent -s)
    # Add private key
    - echo "$SSH_PRIVATE_KEY" | ssh-add -
    # Add host keys
    - mkdir /root/.ssh/
    - echo "$SSH_SERVER_HOSTKEYS" > ~/.ssh/known_hosts
    # Cleanup old socket
    - rm -f docker-socket-ssh
  artifacts:
    paths:
      - docker-compose-stack.yml
    expire_in: 1 week
    when: always
  only:
    - /^release\/.*$/

.docker-compose-login: &docker-compose-login
  image: tiangolo/docker-with-compose
  services:
    - docker:18-dind
  before_script:
    - echo $CI_JOB_TOKEN | docker login -u gitlab-ci-token --password-stdin $CI_REGISTRY

# ======================
# Testing
# ======================

# jest:
#   stage: test
#   image: tiangolo/docker-with-compose
#   services:
#     - docker:dind
#   script:
#     - docker-compose -f docker-compose.jest.yml up -d
#     - docker-compose -f docker-compose.jest.yml run --rm frontend npm ci
#     - docker-compose -f docker-compose.jest.yml run --rm frontend npm test

# # ======================
# # Build stage
# # ======================

# build release:
#   stage: build
#   image: docker:stable
#   services:
#     - docker:dind
#   before_script:
#     - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
#     - export DOCKER_TAG="$CI_COMMIT_REF_SLUG.$CI_PIPELINE_ID"
#   script:
#     - docker build . -t "$CI_REGISTRY_IMAGE":$DOCKER_TAG -f Dockerfile-prod
#     - docker push "$CI_REGISTRY_IMAGE":$DOCKER_TAG
#     - docker run
#       -w /app
#       -v "$PWD":/app
#       -e GITLAB_TOKEN
#       -e CI_COMMIT_REF_NAME
#       -e CI_REGISTRY_IMAGE
#       -e DOCKER_TAG
#       -e STABLE_RELEASE
#       node:10-alpine
#       /bin/sh -c "npm ci && npm run update-releases"
#   only:
#     - /^release\/.*$/

# build ci:
#   stage: build
#   <<: *docker-compose-login
#   script:
#     - docker pull $FRONTEND_IMAGE:latest || true
#     - docker-compose -f docker-compose.ci.yml pull -q frontend || true
#     - docker-compose -f docker-compose.ci.yml build frontend
#     - docker-compose -f docker-compose.ci.yml push frontend

# # ======================
# # Regression stage
# # ======================

# regression:
#   stage: regression
#   <<: *docker-compose-login
#   script:
#     - docker-compose -f docker-compose.ci.yml pull -q
#     - docker-compose -f docker-compose.ci.yml up -d frontend
#     - docker-compose -f docker-compose.ci.yml run -T wait-for-frontend
#     - docker-compose -f docker-compose.ci.yml run -T regression --parallel 10 --world-parameters "`cat test/regression/defaults.json`"
#   artifacts:
#     paths:
#       - test/regression/results/screenshots/
#     expire_in: 1 week
#     when: on_failure

# # ======================
# # Push stage
# # ======================

# push-frontend:
#   stage: push
#   <<: *docker-compose-login
#   script:
#     - docker pull $FRONTEND_IMAGE:$IMAGE_TAG
#     - docker tag $FRONTEND_IMAGE:$IMAGE_TAG $FRONTEND_IMAGE:latest
#     - docker push $FRONTEND_IMAGE:latest
#   only:
#     - /^release\/.*$/

# ======================
# Changelog stage
# ======================

finish wip:
  stage: changelog
  image: node:10-alpine
  before_script:
    - apk add --no-cache git
    - git config --global user.email "epic@enrise.com"
    - git config --global user.name "epic"
  script:
    - git fetch origin ${CI_COMMIT_REF_NAME}
    - git checkout ${CI_COMMIT_REF_NAME}
    - npm ci
    - npm run finish-wip
    - git add --all
    - git commit -m "[ci skip] ${CI_COMMIT_REF_NAME} changelog update"
    - git push https://gitlab-ci-token:${GNIJ_ACCESS_TOKEN}@gitlab.enrise.com/Epic/nijmegen-component-library.git/
  # only:
  #   - /^release\/.*$/

update changelogs:
  stage: changelog
  image: node:10-alpine
  before_script:
    - apk add --no-cache git
    - export MAJOR_VERSION_NUMBER=$(echo "${CI_COMMIT_REF_NAME}" | tail -c 2)
    - export CHANGES_FILE_COUNT=$(ls changelogs/unreleased/ | wc -l)
    - if [ ${CHANGES_FILE_COUNT} -gt 0 ] ; then git config --global user.email "epic@enrise.com" ; fi
    - if [ ${CHANGES_FILE_COUNT} -gt 0 ] ; then git config --global user.name "epic" ; fi
  script:
    - if [ ${CHANGES_FILE_COUNT} -gt 0 ] ; then git fetch origin ${CI_COMMIT_REF_NAME} ; fi
    - if [ ${CHANGES_FILE_COUNT} -gt 0 ] ; then git checkout ${CI_COMMIT_REF_NAME} ; fi
    - if [ ${CHANGES_FILE_COUNT} -gt 0 ] ; then git pull origin ${CI_COMMIT_REF_NAME} ; fi
    - if [ ${CHANGES_FILE_COUNT} -gt 0 ] ; then npm ci && npm run update-changelog "${MAJOR_VERSION_NUMBER}.0.0" ; fi
    - if [ ${CHANGES_FILE_COUNT} -gt 0 ] ; then git add --all ; fi
    - if [ ${CHANGES_FILE_COUNT} -gt 0 ] ; then git commit -m "${CI_COMMIT_REF_NAME} changelog update" ; fi
    - if [ ${CHANGES_FILE_COUNT} -gt 0 ] ; then git push https://gitlab-ci-token:${GNIJ_ACCESS_TOKEN}@gitlab.enrise.com/Epic/nijmegen-component-library.git/ ; fi
  only:
    - /^release\/.*$/

# ======================
# Deploy stage
# ======================

deploy acceptance:
  environment:
    name: acceptance
    url: https://componenten.acc.nijmegen.nl
  <<: *prepare-deploy
  script:
    # Setup SSH tunnel to Docker Engine
    - ssh -o ProxyCommand="ssh -W %h:%p -q enrise@jump01.nijmegen.cobytes.io" -M -S docker-socket-ssh -fnNT -L 50040:127.0.0.1:2375 enrise-docker-deploy@acc01.nijmegen.cobytes.io
    - ssh -S docker-socket-ssh -O check enrise-docker-deploy@acc01.nijmegen.cobytes.io
    # Let Docker authenticate against the GitLab registry
    - DOCKER_HOST=tcp://127.0.0.1:50040 docker login -u gitlab+deploy-token-2 -p $DEPLOY_TOKEN $CI_REGISTRY
    # Generate docker-compose.yml
    - docker run
      -w /app
      -v "$PWD":/app
      -e GITLAB_TOKEN
      -e CI_COMMIT_REF_NAME
      -e CI_REGISTRY_IMAGE
      -e CI_ENVIRONMENT_URL
      -e DOCKER_TAG
      -e STABLE_RELEASE
      node:10-alpine
      npm run prepare-deployment
    # Deploy the stack
    - DOCKER_HOST=tcp://127.0.0.1:50040 docker stack deploy --with-registry-auth --compose-file=docker-compose-stack.yml ${SERVICE_NAME}
    # Exit SSH tunnel
    - ssh -S docker-socket-ssh -O exit enrise-docker-deploy@acc01.nijmegen.cobytes.io

deploy production:
  environment:
    name: production
    url: https://componenten.nijmegen.nl
  when: manual
  <<: *prepare-deploy
  script:
    # Setup SSH tunnel to Docker Engine
    - ssh -o ProxyCommand="ssh -W %h:%p -q enrise@jump01.nijmegen.cobytes.io" -M -S docker-socket-ssh -fnNT -L 50040:127.0.0.1:2375 enrise-docker-deploy@containerprod01.nijmegen.cobytes.io
    - ssh -S docker-socket-ssh -O check enrise-docker-deploy@containerprod01.nijmegen.cobytes.io
    # Let Docker authenticate against the GitLab registry
    - DOCKER_HOST=tcp://127.0.0.1:50040 docker login -u gitlab+deploy-token-2 -p $DEPLOY_TOKEN $CI_REGISTRY
    # Generate docker-compose.yml
    - docker run
      -w /app
      -v "$PWD":/app
      -e GITLAB_TOKEN
      -e CI_COMMIT_REF_NAME
      -e CI_REGISTRY_IMAGE
      -e CI_ENVIRONMENT_URL
      -e DOCKER_TAG
      -e STABLE_RELEASE
      node:10-alpine
      npm run prepare-deployment
    # Deploy the stack
    - DOCKER_HOST=tcp://127.0.0.1:50040 docker stack deploy --with-registry-auth --compose-file=docker-compose-stack.yml ${SERVICE_NAME}
    # Exit SSH tunnel
    - ssh -S docker-socket-ssh -O exit enrise-docker-deploy@containerprod01.nijmegen.cobytes.io
